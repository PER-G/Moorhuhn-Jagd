<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üêî H√ºhnerjagd - Wellenmodus</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Permanent+Marker&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a2e;
    overflow: hidden;
    font-family: 'Bangers', cursive;
    user-select: none;
    -webkit-user-select: none;
  }

  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
  }

  canvas {
    display: block;
    cursor: crosshair;
  }

  #hud {
    position: absolute;
    top: 0; left: 0; right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px;
    background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
    pointer-events: none;
    z-index: 10;
  }

  .hud-item {
    color: #fff;
    font-size: 22px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(255,200,0,0.3);
    letter-spacing: 2px;
  }

  .hud-item span {
    color: #ffd700;
    font-size: 26px;
  }

  .hud-item .time-critical {
    color: #ff4444;
    animation: pulse 0.5s infinite alternate;
  }

  @keyframes pulse {
    from { opacity: 1; }
    to { opacity: 0.5; }
  }

  #hudRow2 {
    position: absolute;
    top: 44px; left: 0; right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px 8px;
    background: linear-gradient(180deg, rgba(0,0,0,0.4) 0%, transparent 100%);
    pointer-events: none;
    z-index: 10;
  }

  #waveProgress {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #ccc;
    font-size: 18px;
    letter-spacing: 1px;
  }

  .progress-bar {
    width: 160px;
    height: 12px;
    background: rgba(0,0,0,0.5);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.2);
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #2ecc71, #27ae60);
    border-radius: 6px;
    transition: width 0.3s;
  }

  #weaponDisplay {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #ff9500;
    font-size: 18px;
    letter-spacing: 1px;
  }

  #ammoDisplay {
    display: flex;
    gap: 3px;
    align-items: center;
  }

  .shell {
    width: 7px;
    height: 18px;
    background: linear-gradient(180deg, #c9a030, #8b6914);
    border-radius: 3px 3px 1px 1px;
    border: 1px solid #daa520;
    transition: opacity 0.2s;
  }

  .shell.empty {
    opacity: 0.2;
    background: #555;
    border-color: #666;
  }

  .shell.shotgun {
    background: linear-gradient(180deg, #e74c3c, #c0392b);
    border-color: #ff6b6b;
    width: 10px;
  }

  .shell.grenade {
    background: linear-gradient(180deg, #27ae60, #1e8449);
    border-color: #2ecc71;
    width: 10px;
    border-radius: 50%;
    height: 12px;
  }

  .shell.rocket {
    background: linear-gradient(180deg, #f39c12, #d68910);
    border-color: #f1c40f;
    width: 10px;
  }

  .shell.bomb {
    background: linear-gradient(180deg, #8e44ad, #6c3483);
    border-color: #a569bd;
    width: 12px;
    border-radius: 50%;
    height: 12px;
  }

  .shell.nuke {
    background: linear-gradient(180deg, #ff0, #ff6600);
    border-color: #fff;
    width: 14px;
    height: 20px;
    border-radius: 4px;
    box-shadow: 0 0 8px rgba(255,255,0,0.6);
  }

  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.8);
    z-index: 20;
    backdrop-filter: blur(4px);
  }

  #overlay.hidden { display: none; }

  #overlay h1 {
    font-family: 'Permanent Marker', cursive;
    font-size: 64px;
    color: #ffd700;
    text-shadow: 3px 3px 0 #8b4513, 6px 6px 0 rgba(0,0,0,0.3);
    margin-bottom: 10px;
    animation: bounceIn 0.6s ease-out;
    text-align: center;
  }

  #overlay h2 {
    font-family: 'Bangers', cursive;
    font-size: 32px;
    color: #fff;
    margin-bottom: 20px;
    letter-spacing: 3px;
  }

  #overlay .subtitle {
    font-family: 'Bangers', cursive;
    font-size: 20px;
    color: #ccc;
    margin-bottom: 8px;
    letter-spacing: 2px;
    text-align: center;
    max-width: 600px;
    line-height: 1.4;
  }

  .btn {
    font-family: 'Permanent Marker', cursive;
    font-size: 28px;
    padding: 14px 44px;
    background: linear-gradient(180deg, #e74c3c, #c0392b);
    color: #fff;
    border: 3px solid #ff6b6b;
    border-radius: 12px;
    cursor: pointer;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    box-shadow: 0 6px 20px rgba(231,76,60,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
    transition: transform 0.15s, box-shadow 0.15s;
    letter-spacing: 2px;
    margin-top: 16px;
  }

  .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 30px rgba(231,76,60,0.5), inset 0 1px 0 rgba(255,255,255,0.2);
  }

  .btn:active { transform: translateY(1px); }

  .btn.green {
    background: linear-gradient(180deg, #27ae60, #1e8449);
    border-color: #2ecc71;
    box-shadow: 0 6px 20px rgba(39,174,96,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
  }

  @keyframes bounceIn {
    0% { transform: scale(0.3); opacity: 0; }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
  }

  .hit-text {
    position: absolute;
    font-family: 'Bangers', cursive;
    font-size: 28px;
    color: #ffd700;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
    pointer-events: none;
    z-index: 15;
    animation: floatUp 0.8s ease-out forwards;
  }

  @keyframes floatUp {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-60px) scale(1.3); opacity: 0; }
  }

  .muzzle-flash {
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: radial-gradient(circle, #fff 0%, #ffd700 40%, transparent 70%);
    pointer-events: none;
    z-index: 15;
    animation: flash 0.15s ease-out forwards;
  }

  @keyframes flash {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(2); opacity: 0; }
  }

  .wave-announce {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Permanent Marker', cursive;
    font-size: 72px;
    color: #ffd700;
    text-shadow: 3px 3px 0 #8b4513, 0 0 30px rgba(255,215,0,0.5);
    pointer-events: none;
    z-index: 25;
    animation: waveAnnounce 2s ease-out forwards;
    white-space: nowrap;
  }

  @keyframes waveAnnounce {
    0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
    15% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    30% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    80% { opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
  }

  .weapon-pickup-text {
    position: absolute;
    font-family: 'Permanent Marker', cursive;
    font-size: 36px;
    color: #ff9500;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(255,149,0,0.5);
    pointer-events: none;
    z-index: 25;
    animation: weaponPickup 1.5s ease-out forwards;
    white-space: nowrap;
  }

  @keyframes weaponPickup {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
    20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    40% { transform: translate(-50%, -50%) scale(1); }
    80% { opacity: 1; }
    100% { transform: translate(-50%, -80%) scale(1); opacity: 0; }
  }

  #nukeFlash {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #fff;
    z-index: 30;
    pointer-events: none;
    opacity: 0;
    display: none;
  }

  #nukeFlash.active {
    display: block;
    animation: nukeFlash 4s ease-out forwards;
  }

  @keyframes nukeFlash {
    0% { opacity: 0; }
    5% { opacity: 1; background: #fff; }
    15% { opacity: 1; background: #ffffcc; }
    30% { opacity: 0.9; background: #ffcc00; }
    60% { opacity: 0.5; background: #ff6600; }
    100% { opacity: 0; }
  }

  .win-text {
    color: #ffd700 !important;
    animation: winGlow 1s infinite alternate;
  }

  @keyframes winGlow {
    from { text-shadow: 3px 3px 0 #8b4513, 0 0 20px rgba(255,215,0,0.5); }
    to { text-shadow: 3px 3px 0 #8b4513, 0 0 40px rgba(255,215,0,0.9), 0 0 80px rgba(255,100,0,0.4); }
  }

  #soundToggle {
    position: absolute;
    bottom: 14px;
    right: 14px;
    z-index: 30;
    font-size: 28px;
    background: rgba(0,0,0,0.5);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 50%;
    width: 46px; height: 46px;
    cursor: pointer;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
  }
  #soundToggle:hover { background: rgba(0,0,0,0.8); }
  #soundToggle.muted { opacity: 0.4; }

  #reloadBtn {
    position: absolute;
    bottom: 14px;
    right: 70px;
    z-index: 30;
    font-family: 'Bangers', cursive;
    font-size: 18px;
    letter-spacing: 2px;
    background: rgba(0,0,0,0.55);
    border: 2px solid rgba(255,215,0,0.4);
    border-radius: 14px;
    padding: 10px 20px;
    cursor: pointer;
    color: #ffd700;
    display: none;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  #reloadBtn:active { background: rgba(255,215,0,0.3); }

  @media (pointer: coarse), (max-width: 800px) {
    #reloadBtn { display: flex; }
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>

  <div id="hud">
    <div class="hud-item">PUNKTE: <span id="scoreDisplay">0</span></div>
    <div class="hud-item" id="ammoDisplay"></div>
    <div class="hud-item">ZEIT: <span id="timeDisplay">30</span></div>
  </div>

  <div id="hudRow2">
    <div id="waveProgress">
      WELLE <span id="waveNum" style="color:#ffd700;">1</span> / 15
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width:0%"></div>
      </div>
      <span id="killCount" style="color:#2ecc71;">0 / 5</span>
    </div>
    <div id="weaponDisplay">üî´ Pistole (‚àû)</div>
  </div>

  <div id="nukeFlash"></div>

  <button id="reloadBtn" title="Nachladen">üîÑ NACHLADEN</button>
  <button id="soundToggle" title="Sound an/aus">üîä</button>

  <div id="overlay">
    <h1>üêî H√úHNERJAGD</h1>
    <h2>Wellenmodus</h2>
    <div class="subtitle">Schie√ü die H√ºhner ab! Jede Welle brauchst du mehr Treffer.</div>
    <div class="subtitle">Alle 3 Wellen f√§llt eine Spezialwaffe vom Himmel ‚Äî schie√ü sie ab!</div>
    <div class="subtitle" style="font-size:16px;color:#999;">Nachladen: R oder Leertaste &nbsp;|&nbsp; 30 Sekunden pro Welle</div>
    <div class="subtitle" style="font-size:15px;color:#777;margin-top:12px;">
      üî¥ Welle 3: Schrotflinte &nbsp;|&nbsp; üü¢ Welle 6: Granatwerfer<br>
      üü† Welle 9: Raketenwerfer &nbsp;|&nbsp; üü£ Welle 12: Bombe<br>
      ‚ò¢Ô∏è Welle 15: Atomrakete ‚Äî Schnapp sie dir & gewinne!
    </div>
    <button class="btn" id="startBtn">LOS GEHT'S!</button>
  </div>
</div>

<script>
// ============================================================
//  DOM REFERENCES
// ============================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const scoreDisplay = document.getElementById('scoreDisplay');
const timeDisplay = document.getElementById('timeDisplay');
const ammoDisplay = document.getElementById('ammoDisplay');
const container = document.getElementById('gameContainer');
const waveNumEl = document.getElementById('waveNum');
const progressFill = document.getElementById('progressFill');
const killCountEl = document.getElementById('killCount');
const weaponDisplayEl = document.getElementById('weaponDisplay');
const nukeFlash = document.getElementById('nukeFlash');

// ============================================================
//  SOUND ENGINE ‚Äî Web Audio API procedural synthesis
// ============================================================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
let soundMuted = false;

function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

document.getElementById('soundToggle').addEventListener('click', () => {
  soundMuted = !soundMuted;
  document.getElementById('soundToggle').textContent = soundMuted ? 'üîá' : 'üîä';
  document.getElementById('soundToggle').classList.toggle('muted', soundMuted);
});

// Helper: create noise buffer
function noiseBuffer(duration, sampleRate) {
  const len = duration * sampleRate;
  const buf = audioCtx.createBuffer(1, len, sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
  return buf;
}

// ---- WEAPON SOUNDS ----

function sndPistol() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Sharp crack
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.setValueAtTime(800, t);
  o.frequency.exponentialRampToValueAtTime(150, t + 0.08);
  g.gain.setValueAtTime(0.35, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t + 0.12);
  // Noise burst
  const nb = audioCtx.createBufferSource();
  nb.buffer = noiseBuffer(0.06, audioCtx.sampleRate);
  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(0.25, t);
  ng.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
  const hp = audioCtx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 2000;
  nb.connect(hp); hp.connect(ng); ng.connect(audioCtx.destination);
  nb.start(t); nb.stop(t + 0.06);
}

function sndShotgun() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Heavy boom
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sawtooth';
  o.frequency.setValueAtTime(400, t);
  o.frequency.exponentialRampToValueAtTime(60, t + 0.15);
  g.gain.setValueAtTime(0.5, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t + 0.2);
  // Wide noise spread
  const nb = audioCtx.createBufferSource();
  nb.buffer = noiseBuffer(0.15, audioCtx.sampleRate);
  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(0.45, t);
  ng.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
  nb.connect(ng); ng.connect(audioCtx.destination);
  nb.start(t); nb.stop(t + 0.15);
  // Second crack (double barrel feel)
  const o2 = audioCtx.createOscillator();
  const g2 = audioCtx.createGain();
  o2.type = 'square';
  o2.frequency.setValueAtTime(600, t + 0.03);
  o2.frequency.exponentialRampToValueAtTime(80, t + 0.18);
  g2.gain.setValueAtTime(0.3, t + 0.03);
  g2.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.start(t + 0.03); o2.stop(t + 0.2);
}

function sndGrenade() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Thump launch
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(200, t);
  o.frequency.exponentialRampToValueAtTime(60, t + 0.1);
  g.gain.setValueAtTime(0.3, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t + 0.12);
  // Delayed explosion
  setTimeout(() => {
    if (soundMuted) return;
    const t2 = audioCtx.currentTime;
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sawtooth';
    ob.frequency.setValueAtTime(300, t2);
    ob.frequency.exponentialRampToValueAtTime(30, t2 + 0.4);
    gb.gain.setValueAtTime(0.6, t2);
    gb.gain.exponentialRampToValueAtTime(0.001, t2 + 0.5);
    ob.connect(gb); gb.connect(audioCtx.destination);
    ob.start(t2); ob.stop(t2 + 0.5);
    const nb2 = audioCtx.createBufferSource();
    nb2.buffer = noiseBuffer(0.35, audioCtx.sampleRate);
    const ng2 = audioCtx.createGain();
    ng2.gain.setValueAtTime(0.5, t2);
    ng2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.35);
    const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 800;
    nb2.connect(lp); lp.connect(ng2); ng2.connect(audioCtx.destination);
    nb2.start(t2); nb2.stop(t2 + 0.35);
  }, 80);
}

function sndRocket() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Whoosh
  const nb = audioCtx.createBufferSource();
  nb.buffer = noiseBuffer(0.4, audioCtx.sampleRate);
  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(0.01, t);
  ng.gain.linearRampToValueAtTime(0.4, t + 0.1);
  ng.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
  const bp = audioCtx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.setValueAtTime(500, t);
  bp.frequency.exponentialRampToValueAtTime(2000, t + 0.15);
  bp.frequency.exponentialRampToValueAtTime(200, t + 0.4);
  bp.Q.value = 2;
  nb.connect(bp); bp.connect(ng); ng.connect(audioCtx.destination);
  nb.start(t); nb.stop(t + 0.4);
  // Impact explosion
  setTimeout(() => {
    if (soundMuted) return;
    const t2 = audioCtx.currentTime;
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sawtooth';
    ob.frequency.setValueAtTime(250, t2);
    ob.frequency.exponentialRampToValueAtTime(20, t2 + 0.6);
    gb.gain.setValueAtTime(0.7, t2);
    gb.gain.exponentialRampToValueAtTime(0.001, t2 + 0.7);
    ob.connect(gb); gb.connect(audioCtx.destination);
    ob.start(t2); ob.stop(t2 + 0.7);
    const nb2 = audioCtx.createBufferSource();
    nb2.buffer = noiseBuffer(0.5, audioCtx.sampleRate);
    const ng2 = audioCtx.createGain();
    ng2.gain.setValueAtTime(0.6, t2);
    ng2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.5);
    nb2.connect(ng2); ng2.connect(audioCtx.destination);
    nb2.start(t2); nb2.stop(t2 + 0.5);
  }, 120);
}

function sndBomb() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Whistle fall
  const ow = audioCtx.createOscillator();
  const gw = audioCtx.createGain();
  ow.type = 'sine';
  ow.frequency.setValueAtTime(1200, t);
  ow.frequency.exponentialRampToValueAtTime(200, t + 0.25);
  gw.gain.setValueAtTime(0.2, t);
  gw.gain.linearRampToValueAtTime(0.35, t + 0.2);
  gw.gain.exponentialRampToValueAtTime(0.001, t + 0.28);
  ow.connect(gw); gw.connect(audioCtx.destination);
  ow.start(t); ow.stop(t + 0.28);
  // Massive explosion
  setTimeout(() => {
    if (soundMuted) return;
    const t2 = audioCtx.currentTime;
    // Sub bass
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sine';
    ob.frequency.setValueAtTime(80, t2);
    ob.frequency.exponentialRampToValueAtTime(15, t2 + 0.8);
    gb.gain.setValueAtTime(0.8, t2);
    gb.gain.exponentialRampToValueAtTime(0.001, t2 + 0.9);
    ob.connect(gb); gb.connect(audioCtx.destination);
    ob.start(t2); ob.stop(t2 + 0.9);
    // Distorted crunch
    const ob2 = audioCtx.createOscillator();
    const gb2 = audioCtx.createGain();
    const dist = audioCtx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = (Math.PI + 4) * x / (Math.PI + 4 * Math.abs(x)); }
    dist.curve = curve;
    ob2.type = 'sawtooth';
    ob2.frequency.setValueAtTime(200, t2);
    ob2.frequency.exponentialRampToValueAtTime(25, t2 + 0.7);
    gb2.gain.setValueAtTime(0.5, t2);
    gb2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.8);
    ob2.connect(dist); dist.connect(gb2); gb2.connect(audioCtx.destination);
    ob2.start(t2); ob2.stop(t2 + 0.8);
    // Noise blast
    const nb2 = audioCtx.createBufferSource();
    nb2.buffer = noiseBuffer(0.7, audioCtx.sampleRate);
    const ng2 = audioCtx.createGain();
    ng2.gain.setValueAtTime(0.7, t2);
    ng2.gain.exponentialRampToValueAtTime(0.001, t2 + 0.7);
    nb2.connect(ng2); ng2.connect(audioCtx.destination);
    nb2.start(t2); nb2.stop(t2 + 0.7);
  }, 200);
}

function sndNuke() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Ascending siren
  const os = audioCtx.createOscillator();
  const gs = audioCtx.createGain();
  os.type = 'sawtooth';
  os.frequency.setValueAtTime(200, t);
  os.frequency.exponentialRampToValueAtTime(3000, t + 1.2);
  gs.gain.setValueAtTime(0.3, t);
  gs.gain.linearRampToValueAtTime(0.5, t + 1);
  gs.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
  os.connect(gs); gs.connect(audioCtx.destination);
  os.start(t); os.stop(t + 1.5);
  // Massive detonation after siren
  setTimeout(() => {
    if (soundMuted) return;
    const t2 = audioCtx.currentTime;
    // Ultra low sub
    const ob = audioCtx.createOscillator();
    const gb = audioCtx.createGain();
    ob.type = 'sine';
    ob.frequency.setValueAtTime(50, t2);
    ob.frequency.exponentialRampToValueAtTime(8, t2 + 2);
    gb.gain.setValueAtTime(1, t2);
    gb.gain.exponentialRampToValueAtTime(0.001, t2 + 2.5);
    ob.connect(gb); gb.connect(audioCtx.destination);
    ob.start(t2); ob.stop(t2 + 2.5);
    // Full spectrum noise
    const nb2 = audioCtx.createBufferSource();
    nb2.buffer = noiseBuffer(2, audioCtx.sampleRate);
    const ng2 = audioCtx.createGain();
    ng2.gain.setValueAtTime(0.8, t2);
    ng2.gain.exponentialRampToValueAtTime(0.001, t2 + 2);
    nb2.connect(ng2); ng2.connect(audioCtx.destination);
    nb2.start(t2); nb2.stop(t2 + 2);
    // Distorted rumble
    const ob2 = audioCtx.createOscillator();
    const dist = audioCtx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 5); }
    dist.curve = curve;
    const gb2 = audioCtx.createGain();
    ob2.type = 'sawtooth';
    ob2.frequency.setValueAtTime(120, t2);
    ob2.frequency.exponentialRampToValueAtTime(10, t2 + 2);
    gb2.gain.setValueAtTime(0.6, t2);
    gb2.gain.exponentialRampToValueAtTime(0.001, t2 + 2.5);
    ob2.connect(dist); dist.connect(gb2); gb2.connect(audioCtx.destination);
    ob2.start(t2); ob2.stop(t2 + 2.5);
  }, 1200);
}

const weaponSounds = {
  pistol: sndPistol,
  shotgun: sndShotgun,
  grenade: sndGrenade,
  rocket: sndRocket,
  bomb: sndBomb,
  nuke: sndNuke
};

// ---- CHICKEN HIT SOUNDS (10 different) ----

function chickenHit_cluck() {
  // Classic chicken cluck
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(600, t);
  o.frequency.setValueAtTime(900, t+0.04);
  o.frequency.setValueAtTime(500, t+0.08);
  o.frequency.setValueAtTime(700, t+0.12);
  g.gain.setValueAtTime(0.3, t);
  g.gain.setValueAtTime(0.15, t+0.06);
  g.gain.setValueAtTime(0.25, t+0.1);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t+0.2);
}

function chickenHit_squawk() {
  // Panicked squawk
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sawtooth';
  o.frequency.setValueAtTime(1200, t);
  o.frequency.exponentialRampToValueAtTime(400, t+0.15);
  o.frequency.setValueAtTime(1000, t+0.16);
  o.frequency.exponentialRampToValueAtTime(300, t+0.3);
  g.gain.setValueAtTime(0.2, t);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t+0.3);
}

function chickenHit_splat() {
  // Wet splat
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const nb = audioCtx.createBufferSource();
  nb.buffer = noiseBuffer(0.12, audioCtx.sampleRate);
  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(0.4, t);
  ng.gain.exponentialRampToValueAtTime(0.001, t+0.12);
  const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 1200;
  nb.connect(lp); lp.connect(ng); ng.connect(audioCtx.destination);
  nb.start(t); nb.stop(t+0.12);
  // Thud
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sine'; o.frequency.setValueAtTime(180, t); o.frequency.exponentialRampToValueAtTime(50, t+0.1);
  g.gain.setValueAtTime(0.35, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.12);
  o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.12);
}

function chickenHit_pop() {
  // Cartoon pop
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(1400, t);
  o.frequency.exponentialRampToValueAtTime(200, t+0.06);
  g.gain.setValueAtTime(0.4, t);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.08);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t+0.08);
}

function chickenHit_bawk() {
  // "BAWK!" descending
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  for (let i = 0; i < 3; i++) {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'triangle';
    const st = t + i * 0.07;
    o.frequency.setValueAtTime(800 - i*150, st);
    o.frequency.exponentialRampToValueAtTime(400 - i*100, st+0.06);
    g.gain.setValueAtTime(0.25, st);
    g.gain.exponentialRampToValueAtTime(0.001, st+0.07);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(st); o.stop(st+0.07);
  }
}

function chickenHit_gobble() {
  // Turkey-like gobble
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'triangle';
  // Wobble frequency
  const lfo = audioCtx.createOscillator();
  const lfoG = audioCtx.createGain();
  lfo.frequency.value = 25;
  lfoG.gain.value = 200;
  lfo.connect(lfoG); lfoG.connect(o.frequency);
  o.frequency.setValueAtTime(500, t);
  o.frequency.linearRampToValueAtTime(350, t+0.25);
  g.gain.setValueAtTime(0.3, t);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); lfo.start(t); o.stop(t+0.3); lfo.stop(t+0.3);
}

function chickenHit_poof() {
  // Feather poof ‚Äî soft burst
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const nb = audioCtx.createBufferSource();
  nb.buffer = noiseBuffer(0.2, audioCtx.sampleRate);
  const ng = audioCtx.createGain();
  ng.gain.setValueAtTime(0.01, t);
  ng.gain.linearRampToValueAtTime(0.3, t+0.02);
  ng.gain.exponentialRampToValueAtTime(0.001, t+0.2);
  const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=3000; bp.Q.value=1;
  nb.connect(bp); bp.connect(ng); ng.connect(audioCtx.destination);
  nb.start(t); nb.stop(t+0.2);
}

function chickenHit_bonk() {
  // Cartoon bonk
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(800, t);
  o.frequency.exponentialRampToValueAtTime(100, t+0.15);
  g.gain.setValueAtTime(0.4, t);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.18);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t+0.18);
  // Rattle
  const o2 = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
  o2.type = 'square';
  o2.frequency.setValueAtTime(2000, t+0.04);
  o2.frequency.exponentialRampToValueAtTime(800, t+0.12);
  g2.gain.setValueAtTime(0.08, t+0.04);
  g2.gain.exponentialRampToValueAtTime(0.001, t+0.12);
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.start(t+0.04); o2.stop(t+0.12);
}

function chickenHit_whistle() {
  // Comical descending whistle (falling chicken)
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(2000, t);
  o.frequency.exponentialRampToValueAtTime(200, t+0.35);
  g.gain.setValueAtTime(0.2, t);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.4);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t+0.4);
}

function chickenHit_spring() {
  // Boing spring
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(300, t);
  o.frequency.exponentialRampToValueAtTime(1500, t+0.05);
  o.frequency.exponentialRampToValueAtTime(200, t+0.15);
  o.frequency.exponentialRampToValueAtTime(1000, t+0.2);
  o.frequency.exponentialRampToValueAtTime(150, t+0.3);
  g.gain.setValueAtTime(0.25, t);
  g.gain.exponentialRampToValueAtTime(0.001, t+0.35);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(t); o.stop(t+0.35);
}

const chickenHitSounds = [
  chickenHit_cluck, chickenHit_squawk, chickenHit_splat, chickenHit_pop,
  chickenHit_bawk, chickenHit_gobble, chickenHit_poof, chickenHit_bonk,
  chickenHit_whistle, chickenHit_spring
];

function playRandomChickenHit() {
  chickenHitSounds[Math.floor(Math.random() * chickenHitSounds.length)]();
}

// ---- UI / FEEDBACK SOUNDS ----

function sndReload() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Click-clack
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'square'; o.frequency.setValueAtTime(1800, t); o.frequency.exponentialRampToValueAtTime(600, t+0.03);
  g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.04);
  o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.04);
  // Second click
  const o2 = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
  o2.type = 'square'; o2.frequency.setValueAtTime(2200, t+0.08); o2.frequency.exponentialRampToValueAtTime(900, t+0.11);
  g2.gain.setValueAtTime(0.15, t+0.08); g2.gain.exponentialRampToValueAtTime(0.001, t+0.12);
  o2.connect(g2); g2.connect(audioCtx.destination); o2.start(t+0.08); o2.stop(t+0.12);
  // Metallic slide
  const nb = audioCtx.createBufferSource(); nb.buffer = noiseBuffer(0.08, audioCtx.sampleRate);
  const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.06, t+0.13); ng.gain.exponentialRampToValueAtTime(0.001, t+0.2);
  const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=4000;
  nb.connect(hp); hp.connect(ng); ng.connect(audioCtx.destination); nb.start(t+0.13); nb.stop(t+0.2);
}

function sndEmpty() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'square'; o.frequency.value = 1500;
  g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.03);
  o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.03);
}

function sndPickup() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Power-up jingle
  const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
  notes.forEach((f, i) => {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'triangle'; o.frequency.value = f;
    const st = t + i * 0.08;
    g.gain.setValueAtTime(0.25, st); g.gain.exponentialRampToValueAtTime(0.001, st + 0.15);
    o.connect(g); g.connect(audioCtx.destination); o.start(st); o.stop(st + 0.15);
  });
}

function sndWaveStart() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Trumpet-like fanfare
  const notes = [392, 523, 659]; // G4 C5 E5
  notes.forEach((f, i) => {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'sawtooth'; o.frequency.value = f;
    const st = t + i * 0.12;
    g.gain.setValueAtTime(0.15, st);
    g.gain.linearRampToValueAtTime(0.2, st + 0.05);
    g.gain.exponentialRampToValueAtTime(0.001, st + 0.25);
    const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2000;
    o.connect(lp); lp.connect(g); g.connect(audioCtx.destination);
    o.start(st); o.stop(st + 0.25);
  });
}

function sndWaveComplete() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const notes = [523, 659, 784, 1047, 1319]; // ascending
  notes.forEach((f, i) => {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'triangle'; o.frequency.value = f;
    const st = t + i * 0.1;
    g.gain.setValueAtTime(0.2, st); g.gain.exponentialRampToValueAtTime(0.001, st + 0.2);
    o.connect(g); g.connect(audioCtx.destination); o.start(st); o.stop(st + 0.2);
  });
}

function sndTimerWarning() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = 'square'; o.frequency.value = 880;
  g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.08);
  o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.08);
}

function sndGameOver() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  const notes = [440, 370, 311, 261]; // descending sad
  notes.forEach((f, i) => {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'triangle'; o.frequency.value = f;
    const st = t + i * 0.2;
    g.gain.setValueAtTime(0.2, st); g.gain.exponentialRampToValueAtTime(0.001, st + 0.35);
    o.connect(g); g.connect(audioCtx.destination); o.start(st); o.stop(st + 0.35);
  });
}

function sndWin() {
  if (soundMuted) return; ensureAudio(); const t = audioCtx.currentTime;
  // Triumphant fanfare
  const notes = [523, 523, 659, 784, 659, 784, 1047];
  const durs = [0.12, 0.12, 0.12, 0.25, 0.12, 0.12, 0.4];
  let off = 0;
  notes.forEach((f, i) => {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'sawtooth'; o.frequency.value = f;
    const st = t + off;
    g.gain.setValueAtTime(0.18, st); g.gain.exponentialRampToValueAtTime(0.001, st + durs[i] + 0.05);
    const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2500;
    o.connect(lp); lp.connect(g); g.connect(audioCtx.destination);
    o.start(st); o.stop(st + durs[i] + 0.05);
    off += durs[i];
  });
}

// ============================================================
//  MAIN GAME CODE
// ============================================================
let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

// ====== GAME STATE ======
let gameState = 'menu';
let score = 0;
let wave = 1;
const maxWave = 15;
let waveKills = 0;
let waveTarget = 5;
let timeLeft = 30;
let ammo = 6;
const maxAmmo = 6;
let totalShots = 0, totalHits = 0;

const WEAPONS = {
  pistol:   { name: 'Pistole',        emoji: 'üî´', maxAmmo: 6,  radius: 0 },
  shotgun:  { name: 'Schrotflinte',   emoji: 'üî¥', maxAmmo: 6,  radius: 80,  shellClass: 'shotgun' },
  grenade:  { name: 'Granatwerfer',   emoji: 'üí£', maxAmmo: 6,  radius: 140, shellClass: 'grenade' },
  rocket:   { name: 'Raketenwerfer',  emoji: 'üöÄ', maxAmmo: 6,  radius: 180, shellClass: 'rocket' },
  bomb:     { name: 'Bombe',          emoji: 'üí•', maxAmmo: 6,  radius: 250, shellClass: 'bomb' },
  nuke:     { name: 'ATOMRAKETE',     emoji: '‚ò¢Ô∏è', maxAmmo: 1,  radius: 9999,shellClass: 'nuke' },
};

let currentWeapon = 'pistol';
let specialAmmo = 0;

let chickens = [];
let particles = [];
let feathers = [];
let clouds = [];
let hills = [];
let trees = [];
let grassTufts = [];
let powerups = [];

let parallaxOffset = 0;
let mouseX = 0, mouseY = 0;
let lastTime = 0;
let timerInterval;
let waveStarting = false;
let waveTransitioning = false;
let shakeAmount = 0;
let shakeDuration = 0;

// ====== LANDSCAPE ======
function generateLandscape() {
  clouds = [];
  for (let i = 0; i < 8; i++) clouds.push({ x: Math.random()*W*1.5, y: 30+Math.random()*H*0.2, w: 80+Math.random()*160, h: 30+Math.random()*50, speed: 0.1+Math.random()*0.3, opacity: 0.4+Math.random()*0.4 });
  hills = [];
  for (let i = 0; i < 12; i++) hills.push({ x:i*(W/5)-W*0.2, y:H*0.55, w:W*0.4, h:60+Math.random()*80, layer:0, color:`hsl(${120+Math.random()*20},${25+Math.random()*10}%,${35+Math.random()*10}%)` });
  for (let i = 0; i < 10; i++) hills.push({ x:i*(W/4)-W*0.2, y:H*0.65, w:W*0.35, h:50+Math.random()*70, layer:1, color:`hsl(${100+Math.random()*30},${30+Math.random()*15}%,${28+Math.random()*12}%)` });
  trees = [];
  for (let i = 0; i < 20; i++) { const l=Math.random()>0.5?0:1; trees.push({ x:Math.random()*W*1.5, y:(l===0?H*0.52:H*0.62)+Math.random()*30, size:l===0?20+Math.random()*25:30+Math.random()*40, layer:l, type:Math.floor(Math.random()*3) }); }
  grassTufts = [];
  for (let i = 0; i < 40; i++) grassTufts.push({ x:Math.random()*W*1.5, y:H*0.72+Math.random()*(H*0.28), size:5+Math.random()*15, blades:3+Math.floor(Math.random()*5) });
}

// ====== DRAWING ======
function drawSky() {
  const grad=ctx.createLinearGradient(0,0,0,H*0.7);
  grad.addColorStop(0,'#87CEEB'); grad.addColorStop(0.4,'#B0E0FF'); grad.addColorStop(0.7,'#E8F4FD'); grad.addColorStop(1,'#F5E6C8');
  ctx.fillStyle=grad; ctx.fillRect(0,0,W,H);
  const sx=W*0.8,sy=H*0.12;
  const sg=ctx.createRadialGradient(sx,sy,10,sx,sy,80);
  sg.addColorStop(0,'rgba(255,250,200,1)'); sg.addColorStop(0.3,'rgba(255,220,100,0.6)'); sg.addColorStop(1,'rgba(255,200,50,0)');
  ctx.fillStyle=sg; ctx.fillRect(sx-80,sy-80,160,160);
}

function drawClouds(dt) {
  clouds.forEach(c=>{ c.x+=c.speed*dt*60; if(c.x>W+c.w)c.x=-c.w;
    ctx.save(); ctx.globalAlpha=c.opacity; ctx.fillStyle='#fff';
    ctx.beginPath(); ctx.ellipse(c.x,c.y,c.w/2,c.h/2,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(c.x-c.w*0.25,c.y+c.h*0.15,c.w*0.35,c.h*0.4,0,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(c.x+c.w*0.2,c.y+c.h*0.1,c.w*0.3,c.h*0.35,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });
}

function drawHills(layer) {
  const off=parallaxOffset*(layer===0?0.05:0.15);
  hills.filter(h=>h.layer===layer).forEach(h=>{
    ctx.fillStyle=h.color; ctx.beginPath();
    ctx.moveTo(h.x+off-h.w/2,h.y); ctx.quadraticCurveTo(h.x+off,h.y-h.h,h.x+off+h.w/2,h.y);
    ctx.lineTo(h.x+off+h.w/2,H); ctx.lineTo(h.x+off-h.w/2,H); ctx.closePath(); ctx.fill();
  });
}

function drawGround() {
  const gy=H*0.72;
  const g=ctx.createLinearGradient(0,gy,0,H);
  g.addColorStop(0,'#4a7c3f'); g.addColorStop(0.3,'#3d6b34'); g.addColorStop(1,'#2d5025');
  ctx.fillStyle=g; ctx.fillRect(0,gy,W,H-gy);
  ctx.strokeStyle='#5a9c4f'; ctx.lineWidth=3; ctx.beginPath();
  for(let x=0;x<W;x+=8){ ctx.moveTo(x,gy); ctx.lineTo(x+3,gy-5-Math.random()*8); } ctx.stroke();
}

function drawTree(t) {
  const off=parallaxOffset*(t.layer===0?0.05:0.15);
  const x=t.x+off, y=t.y, s=t.size;
  ctx.fillStyle='#5c3d1e'; ctx.fillRect(x-s*0.08,y-s*0.3,s*0.16,s*0.5);
  ctx.fillStyle=t.layer===0?'#2d6b2d':'#3a8a3a';
  if(t.type===0){ ctx.beginPath(); ctx.arc(x,y-s*0.5,s*0.4,0,Math.PI*2); ctx.fill(); }
  else if(t.type===1){ for(let i=0;i<3;i++){ ctx.beginPath(); ctx.moveTo(x,y-s*(0.4+i*0.25)); ctx.lineTo(x-s*(0.35-i*0.08),y-s*(0.1+i*0.2)); ctx.lineTo(x+s*(0.35-i*0.08),y-s*(0.1+i*0.2)); ctx.closePath(); ctx.fill(); } }
  else{ ctx.beginPath(); ctx.ellipse(x,y-s*0.45,s*0.45,s*0.3,0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(x-s*0.15,y-s*0.6,s*0.3,s*0.25,0,0,Math.PI*2); ctx.fill(); }
}

function drawTrees(layer) { trees.filter(t=>t.layer===layer).forEach(drawTree); }

// ====== CHICKEN ======
class Chicken {
  constructor(speedMult) {
    const dir=Math.random()>0.5?1:-1;
    this.x=dir===1?-60:W+60;
    this.y=60+Math.random()*(H*0.42);
    this.vx=dir*(1.5+Math.random()*2.5)*speedMult;
    this.vy=(Math.random()-0.5)*1.5;
    this.size=22+Math.random()*22;
    this.wingPhase=Math.random()*Math.PI*2;
    this.wingSpeed=6+Math.random()*4;
    this.bobPhase=Math.random()*Math.PI*2;
    this.alive=true; this.deathTimer=0; this.deathVy=0; this.rotation=0; this.rotSpeed=0;
    this.points=Math.round((50-this.size)*0.5+Math.abs(this.vx)*5);
    if(this.points<5)this.points=5;
    this.bodyColor=['#c0392b','#e74c3c','#d35400','#8e44ad','#2980b9','#27ae60','#e67e22','#1abc9c'][Math.floor(Math.random()*8)];
    this.counted=false;
  }
  update(dt) {
    if(this.alive){ this.x+=this.vx*dt*60; this.y+=Math.sin(this.bobPhase)*0.5; this.bobPhase+=0.03*dt*60; this.wingPhase+=this.wingSpeed*dt; this.y+=this.vy*dt*10; if(this.y<40)this.vy=Math.abs(this.vy); if(this.y>H*0.5)this.vy=-Math.abs(this.vy); }
    else{ this.deathTimer+=dt; this.deathVy+=400*dt; this.y+=this.deathVy*dt; this.rotation+=this.rotSpeed*dt; }
  }
  draw() {
    ctx.save(); ctx.translate(this.x,this.y);
    const dir=this.vx>0?1:-1; ctx.scale(dir,1);
    if(!this.alive){ ctx.rotate(this.rotation); ctx.globalAlpha=Math.max(0,1-this.deathTimer*0.8); }
    const s=this.size;
    const wa=Math.sin(this.wingPhase)*0.5;
    ctx.save(); ctx.translate(-s*0.1,-s*0.1); ctx.rotate(wa-0.3);
    ctx.fillStyle=this.bodyColor; ctx.beginPath(); ctx.ellipse(0,0,s*0.5,s*0.2,0,0,Math.PI*2); ctx.fill(); ctx.restore();
    ctx.fillStyle=this.bodyColor; ctx.beginPath(); ctx.ellipse(0,0,s*0.4,s*0.3,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#f5d6a0'; ctx.beginPath(); ctx.ellipse(s*0.05,s*0.1,s*0.25,s*0.18,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=this.bodyColor; ctx.beginPath(); ctx.arc(s*0.3,-s*0.2,s*0.2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(s*0.38,-s*0.24,s*0.08,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(s*0.4,-s*0.24,s*0.04,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#f39c12'; ctx.beginPath(); ctx.moveTo(s*0.48,-s*0.2); ctx.lineTo(s*0.65,-s*0.17); ctx.lineTo(s*0.48,-s*0.12); ctx.closePath(); ctx.fill();
    ctx.fillStyle='#e74c3c';
    ctx.beginPath(); ctx.arc(s*0.28,-s*0.38,s*0.06,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(s*0.35,-s*0.4,s*0.07,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(s*0.22,-s*0.35,s*0.05,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#c0392b'; ctx.beginPath(); ctx.ellipse(s*0.4,-s*0.06,s*0.04,s*0.07,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=this.bodyColor;
    for(let i=0;i<3;i++){ ctx.save(); ctx.translate(-s*0.35,-s*0.05); ctx.rotate(-0.3-i*0.2); ctx.beginPath(); ctx.ellipse(0,0,s*0.35,s*0.06,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    if(this.alive){ ctx.strokeStyle='#d4900a'; ctx.lineWidth=2; const lp=Math.sin(this.wingPhase*0.5);
      for(let side=-1;side<=1;side+=2){ ctx.beginPath(); ctx.moveTo(side*s*0.1,s*0.25); ctx.lineTo(side*s*0.1+lp*3,s*0.4); ctx.stroke(); } }
    ctx.restore();
  }
  hitTest(mx,my){ const dx=mx-this.x,dy=my-this.y; return Math.sqrt(dx*dx+dy*dy)<this.size*0.5; }
  die(){
    this.alive=false; this.deathVy=-3; this.rotSpeed=(Math.random()-0.5)*10;
    for(let i=0;i<8;i++) feathers.push({ x:this.x+(Math.random()-0.5)*20, y:this.y+(Math.random()-0.5)*20, vx:(Math.random()-0.5)*4, vy:-2-Math.random()*3, rot:Math.random()*Math.PI*2, rotSpeed:(Math.random()-0.5)*5, size:4+Math.random()*6, color:this.bodyColor, life:1 });
  }
  offScreen(){ return this.x<-100||this.x>W+100||this.y>H+100; }
}

// ====== POWERUP ======
class Powerup {
  constructor(weaponType) {
    this.x=100+Math.random()*(W-200); this.y=-50; this.vy=1.2+Math.random()*0.8;
    this.size=36; this.weaponType=weaponType; this.alive=true; this.bobPhase=Math.random()*Math.PI*2;
    this.glow=0; this.emoji=WEAPONS[weaponType].emoji; this.label=WEAPONS[weaponType].name;
  }
  update(dt){ this.y+=this.vy*dt*60; this.bobPhase+=3*dt; this.glow=0.5+Math.sin(this.bobPhase)*0.5; if(this.y>H+60)this.alive=false; }
  draw(){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.strokeStyle='#aaa'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(-20,-10); ctx.quadraticCurveTo(0,-50,20,-10); ctx.stroke();
    ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.moveTo(-20,-10); ctx.quadraticCurveTo(0,-55,20,-10); ctx.quadraticCurveTo(0,-20,-20,-10); ctx.fill();
    ctx.beginPath(); ctx.moveTo(-18,-12); ctx.lineTo(-6,4); ctx.moveTo(18,-12); ctx.lineTo(6,4); ctx.moveTo(0,-15); ctx.lineTo(0,0); ctx.stroke();
    const gc=this.weaponType==='nuke'?`rgba(255,255,0,${this.glow*0.5})`:`rgba(255,149,0,${this.glow*0.3})`;
    const gr=ctx.createRadialGradient(0,4,5,0,4,this.size);
    gr.addColorStop(0,gc); gr.addColorStop(1,'transparent');
    ctx.fillStyle=gr; ctx.fillRect(-this.size,4-this.size,this.size*2,this.size*2);
    ctx.fillStyle=this.weaponType==='nuke'?'#ff4400':'#8B4513';
    ctx.strokeStyle=this.weaponType==='nuke'?'#ffcc00':'#654321';
    ctx.lineWidth=2; const bs=18;
    ctx.fillRect(-bs,-bs/2+4,bs*2,bs); ctx.strokeRect(-bs,-bs/2+4,bs*2,bs);
    ctx.strokeStyle=this.weaponType==='nuke'?'#fff':'#daa520'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(0,-bs/2+5); ctx.lineTo(0,bs/2+3); ctx.moveTo(-bs+1,4); ctx.lineTo(bs-1,4); ctx.stroke();
    ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.emoji,0,5);
    ctx.restore();
  }
  hitTest(mx,my){ const dx=mx-this.x,dy=my-this.y; return Math.sqrt(dx*dx+dy*dy)<this.size; }
}

// ====== PARTICLES ======
function spawnHitParticles(x,y,count=12){ for(let i=0;i<count;i++) particles.push({x,y,vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,size:2+Math.random()*3,color:`hsl(${40+Math.random()*20},100%,${50+Math.random()*30}%)`,life:1}); }

function spawnExplosion(x,y,radius,c1,c2){
  const count=Math.min(radius*0.5,80);
  for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2,sp=2+Math.random()*8; particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,size:3+Math.random()*6,color:Math.random()>0.5?c1:c2,life:1}); }
  shakeAmount=Math.min(radius*0.1,20); shakeDuration=0.3;
}

function updateParticles(dt){
  particles=particles.filter(p=>{p.x+=p.vx*dt*60;p.y+=p.vy*dt*60;p.vy+=3*dt;p.life-=dt*2;return p.life>0;});
  feathers=feathers.filter(f=>{f.x+=f.vx*dt*60;f.y+=f.vy*dt*60;f.vy+=1.5*dt;f.rot+=f.rotSpeed*dt;f.life-=dt*0.8;return f.life>0;});
}

function drawParticles(){
  particles.forEach(p=>{ctx.save();ctx.globalAlpha=p.life;ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill();ctx.restore();});
  feathers.forEach(f=>{ctx.save();ctx.globalAlpha=f.life;ctx.translate(f.x,f.y);ctx.rotate(f.rot);ctx.fillStyle=f.color;ctx.beginPath();ctx.ellipse(0,0,f.size,f.size*0.3,0,0,Math.PI*2);ctx.fill();ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.lineWidth=0.5;ctx.beginPath();ctx.moveTo(-f.size,0);ctx.lineTo(f.size,0);ctx.stroke();ctx.restore();});
}

// ====== UI ======
function updateAmmoUI(){
  ammoDisplay.innerHTML='';
  if(currentWeapon!=='pistol'&&specialAmmo>0){
    const sc=WEAPONS[currentWeapon].shellClass||'';
    for(let i=0;i<3;i++){const s=document.createElement('div');s.className='shell '+sc+(i>=specialAmmo?' empty':'');ammoDisplay.appendChild(s);}
  } else {
    for(let i=0;i<maxAmmo;i++){const s=document.createElement('div');s.className='shell'+(i>=ammo?' empty':'');ammoDisplay.appendChild(s);}
  }
}

function updateWeaponUI(){
  const w=WEAPONS[currentWeapon];
  if(currentWeapon==='pistol'){ weaponDisplayEl.textContent=`${w.emoji} ${w.name} (‚àû)`; weaponDisplayEl.style.color='#aaa'; }
  else{ weaponDisplayEl.textContent=`${w.emoji} ${w.name} (${specialAmmo} Schuss)`; weaponDisplayEl.style.color='#ff9500'; }
}

function updateWaveUI(){
  waveNumEl.textContent=wave;
  progressFill.style.width=Math.min(100,(waveKills/waveTarget)*100)+'%';
  killCountEl.textContent=`${waveKills} / ${waveTarget}`;
}

// ====== SHOOTING ======
function shoot(mx,my){
  if(gameState!=='playing'||waveStarting) return;
  ensureAudio();

  const usingSpecial=currentWeapon!=='pistol'&&specialAmmo>0;
  let firedWeapon = currentWeapon;

  if(usingSpecial){
    specialAmmo--; totalShots++;
    // Play weapon sound
    weaponSounds[firedWeapon]();
    if(specialAmmo<=0) currentWeapon='pistol';
    updateAmmoUI(); updateWeaponUI();
  } else {
    if(ammo<=0){ sndEmpty(); return; }
    ammo--; totalShots++;
    firedWeapon = 'pistol';
    sndPistol();
    updateAmmoUI();
  }

  // muzzle flash
  const flash=document.createElement('div');
  flash.className='muzzle-flash';
  flash.style.left=(mx-20)+'px'; flash.style.top=(my-20)+'px';
  container.appendChild(flash); setTimeout(()=>flash.remove(),200);

  const shotRadius=WEAPONS[firedWeapon].radius||0;

  // NUKE
  if(firedWeapon==='nuke'){ triggerNuke(mx, my); return; }

  // Explosion visual for area weapons
  if(shotRadius>0){
    const colors={shotgun:['#ff4444','#ff8800'],grenade:['#44ff44','#88ff00'],rocket:['#ffaa00','#ff4400'],bomb:['#aa44ff','#ff00ff']};
    const [c1,c2]=colors[firedWeapon]||['#ffd700','#ff8800'];
    spawnExplosion(mx,my,shotRadius,c1,c2);
  }

  // Check powerups
  for(let i=powerups.length-1;i>=0;i--){
    const p=powerups[i];
    if(p.alive&&p.hitTest(mx,my)){ pickupWeapon(p); p.alive=false; break; }
  }

  // Check chicken hits
  if(shotRadius>0){
    let hitAny=false;
    chickens.forEach(c=>{
      if(!c.alive)return;
      const dx=mx-c.x,dy=my-c.y;
      if(Math.sqrt(dx*dx+dy*dy)<shotRadius){ killChicken(c,mx,my); hitAny=true; }
    });
    if(hitAny) totalHits++;
  } else {
    for(let i=chickens.length-1;i>=0;i--){
      const c=chickens[i];
      if(c.alive&&c.hitTest(mx,my)){ killChicken(c,mx,my); totalHits++; break; }
    }
  }
}

function killChicken(c,mx,my){
  c.die(); score+=c.points;
  playRandomChickenHit();
  if(!c.counted){ c.counted=true; waveKills++; updateWaveUI(); }
  scoreDisplay.textContent=score;
  spawnHitParticles(c.x,c.y);
  const txt=document.createElement('div');
  txt.className='hit-text'; txt.textContent='+'+c.points;
  txt.style.left=(c.x-20)+'px'; txt.style.top=(c.y-20)+'px';
  container.appendChild(txt); setTimeout(()=>txt.remove(),900);
  if(waveKills>=waveTarget && !waveTransitioning) waveComplete();
}

function pickupWeapon(p){
  sndPickup();
  if(p.weaponType==='nuke'){ currentWeapon='nuke'; specialAmmo=1; }
  else{ currentWeapon=p.weaponType; specialAmmo=3; }
  updateWeaponUI(); updateAmmoUI();
  spawnHitParticles(p.x,p.y,20);
  const txt=document.createElement('div');
  txt.className='weapon-pickup-text';
  txt.textContent=`${WEAPONS[p.weaponType].emoji} ${WEAPONS[p.weaponType].name}!`;
  txt.style.left=p.x+'px'; txt.style.top=p.y+'px';
  container.appendChild(txt); setTimeout(()=>txt.remove(),1600);
}

function triggerNuke(mx, my){
  sndNuke();
  nukeFlash.classList.add('active');
  shakeAmount=30; shakeDuration=2;
  // Explosion centered on click
  spawnExplosion(mx, my, 500, '#ffff00', '#ff4400');
  // After the siren delay, kill all chickens everywhere
  setTimeout(()=>{
    spawnExplosion(W/2, H/3, 600, '#ffffff', '#ff8800');
    chickens.forEach(c=>{
      if(c.alive){ c.die(); score+=c.points; if(!c.counted){c.counted=true;waveKills++;} spawnHitParticles(c.x,c.y,6); }
    });
    scoreDisplay.textContent=score;
    // Also kill any new chickens that may spawn
    const nukeKillInterval = setInterval(()=>{
      chickens.forEach(c=>{ if(c.alive){ c.die(); spawnHitParticles(c.x,c.y,4); } });
    }, 200);
    setTimeout(()=>{
      clearInterval(nukeKillInterval);
      nukeFlash.classList.remove('active');
      winGame();
    }, 2500);
  }, 1200);
}

function reload(){
  if(currentWeapon==='pistol'&&ammo<maxAmmo){ ammo=maxAmmo; sndReload(); updateAmmoUI(); }
}

// ====== WAVE SYSTEM ======
function getWaveTarget(w){ return 4+w; }
function getSpeedMult(w){ return 1+(w-1)*0.08; }
function getSpecialWeapon(w){
  if(w>=15) return 'nuke';
  if(w>=12) return 'bomb';
  if(w>=9) return 'rocket';
  if(w>=6) return 'grenade';
  if(w>=3) return 'shotgun';
  return null;
}

function startWave(){
  waveKills=0; waveTarget=getWaveTarget(wave); timeLeft=30;
  waveTransitioning=false;
  timeDisplay.textContent='30'; timeDisplay.className='';
  chickens=[]; powerups=[];
  updateWaveUI(); updateWeaponUI();
  waveStarting=true;

  sndWaveStart();

  const ann=document.createElement('div');
  ann.className='wave-announce'; ann.textContent=`WELLE ${wave}`;
  container.appendChild(ann);

  const specialWpn=getSpecialWeapon(wave);
  if(specialWpn){
    const ann2=document.createElement('div');
    ann2.className='wave-announce';
    ann2.style.fontSize='36px'; ann2.style.top='calc(50% + 60px)';
    ann2.style.color=specialWpn==='nuke'?'#ff4400':'#ff9500';
    ann2.textContent=`${WEAPONS[specialWpn].emoji} ${WEAPONS[specialWpn].name} incoming!`;
    container.appendChild(ann2); setTimeout(()=>ann2.remove(),2500);
    setTimeout(()=>{ if(gameState==='playing') powerups.push(new Powerup(specialWpn)); },3000+Math.random()*5000);
  }

  setTimeout(()=>{
    ann.remove(); waveStarting=false;
    if(timerInterval)clearInterval(timerInterval);
    timerInterval=setInterval(()=>{
      if(gameState!=='playing')return;
      timeLeft--;
      timeDisplay.textContent=timeLeft;
      if(timeLeft<=5){ timeDisplay.className='time-critical'; sndTimerWarning(); }
      if(timeLeft<=0) gameover('time');
    },1000);
  },1800);
}

function waveComplete(){
  if(waveTransitioning) return;
  waveTransitioning=true;
  clearInterval(timerInterval);
  sndWaveComplete();
  if(wave>=maxWave){ winGame(); return; }
  wave++;
  setTimeout(()=>{ if(gameState==='playing') startWave(); },1500);
}

function gameover(reason){
  gameState='ended'; clearInterval(timerInterval);
  sndGameOver();
  const acc=totalShots>0?Math.round((totalHits/totalShots)*100):0;
  overlay.classList.remove('hidden');
  overlay.innerHTML=`
    <h1>${reason==='time'?'ZEIT ABGELAUFEN!':'SPIEL VORBEI!'}</h1>
    <h2>Welle ${wave} / ${maxWave}</h2>
    <div style="font-family:'Permanent Marker',cursive;font-size:56px;color:#ffd700;text-shadow:3px 3px 0 #8b4513;">${score}</div>
    <div style="font-family:'Bangers',cursive;font-size:22px;color:#aaa;margin:8px 0 20px;">
      ${totalHits} Treffer / ${totalShots} Sch√ºsse (${acc}% Genauigkeit)<br>
      Erreicht: Welle ${wave} ‚Äî ${waveKills}/${waveTarget} H√ºhner
    </div>
    <button class="btn" onclick="restartGame()">NOCHMAL!</button>
  `;
}

function winGame(){
  gameState='won'; clearInterval(timerInterval);
  setTimeout(()=>sndWin(), 500);
  const acc=totalShots>0?Math.round((totalHits/totalShots)*100):0;
  overlay.classList.remove('hidden');
  overlay.innerHTML=`
    <h1 class="win-text">‚ò¢Ô∏è TOTALE VERNICHTUNG!</h1>
    <h2 style="color:#ffd700;">DU HAST GEWONNEN!</h2>
    <div style="font-family:'Bangers',cursive;font-size:24px;color:#ff9500;margin-bottom:12px;">
      Die Atomrakete hat alles zerst√∂rt! üí•
    </div>
    <div style="font-family:'Permanent Marker',cursive;font-size:56px;color:#ffd700;text-shadow:3px 3px 0 #8b4513;">${score} Punkte</div>
    <div style="font-family:'Bangers',cursive;font-size:22px;color:#aaa;margin:8px 0 20px;">
      ${totalHits} Treffer / ${totalShots} Sch√ºsse (${acc}% Genauigkeit)<br>
      Alle 15 Wellen √ºberlebt!
    </div>
    <button class="btn green" onclick="restartGame()">NOCHMAL SPIELEN!</button>
  `;
}

// ====== CROSSHAIR ======
function drawCrosshair(){
  ctx.save();
  let color='rgba(255,0,0,0.7)', size=18;
  if(currentWeapon==='shotgun'&&specialAmmo>0){color='rgba(255,50,50,0.8)';size=30;}
  else if(currentWeapon==='grenade'&&specialAmmo>0){color='rgba(50,255,50,0.8)';size=40;}
  else if(currentWeapon==='rocket'&&specialAmmo>0){color='rgba(255,170,0,0.8)';size=50;}
  else if(currentWeapon==='bomb'&&specialAmmo>0){color='rgba(170,50,255,0.8)';size=60;}
  else if(currentWeapon==='nuke'&&specialAmmo>0){color='rgba(255,255,0,0.9)';size=80;}
  ctx.strokeStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(mouseX,mouseY,size,0,Math.PI*2); ctx.stroke();
  if(currentWeapon!=='pistol'&&specialAmmo>0){
    const r=WEAPONS[currentWeapon].radius;
    if(r>0&&r<9999){ctx.setLineDash([5,5]);ctx.globalAlpha=0.3;ctx.beginPath();ctx.arc(mouseX,mouseY,r,0,Math.PI*2);ctx.stroke();ctx.setLineDash([]);ctx.globalAlpha=1;}
  }
  ctx.beginPath();
  ctx.moveTo(mouseX-size-6,mouseY);ctx.lineTo(mouseX-size+6,mouseY);
  ctx.moveTo(mouseX+size-6,mouseY);ctx.lineTo(mouseX+size+6,mouseY);
  ctx.moveTo(mouseX,mouseY-size-6);ctx.lineTo(mouseX,mouseY-size+6);
  ctx.moveTo(mouseX,mouseY+size-6);ctx.lineTo(mouseX,mouseY+size+6);
  ctx.stroke();
  ctx.fillStyle=color; ctx.beginPath(); ctx.arc(mouseX,mouseY,2,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// ====== MAIN LOOP ======
function gameLoop(timestamp){
  if(!lastTime)lastTime=timestamp;
  const dt=Math.min((timestamp-lastTime)/1000,0.05);
  lastTime=timestamp;
  parallaxOffset=(mouseX-W/2)*0.1;

  let shakeX=0,shakeY=0;
  if(shakeDuration>0){ shakeDuration-=dt; shakeX=(Math.random()-0.5)*shakeAmount*2; shakeY=(Math.random()-0.5)*shakeAmount*2; shakeAmount*=0.95; }

  ctx.save(); ctx.translate(shakeX,shakeY);
  ctx.clearRect(-10,-10,W+20,H+20);

  drawSky(); drawClouds(dt); drawHills(0); drawTrees(0); drawHills(1); drawTrees(1); drawGround();

  const gOff=parallaxOffset*0.2;
  grassTufts.forEach(g=>{
    ctx.strokeStyle='#5a9c4f'; ctx.lineWidth=1.5;
    for(let i=0;i<g.blades;i++){
      const angle=-0.4+(i/g.blades)*0.8+Math.sin(timestamp/1000+g.x)*0.1;
      ctx.beginPath(); ctx.moveTo(g.x+gOff,g.y);
      ctx.quadraticCurveTo(g.x+gOff+Math.sin(angle)*g.size*0.5,g.y-g.size*0.5,g.x+gOff+Math.sin(angle)*g.size,g.y-g.size);
      ctx.stroke();
    }
  });

  if(gameState==='playing'&&!waveStarting){
    const spawnRate=0.025+wave*0.005;
    if(Math.random()<spawnRate*dt*60&&chickens.filter(c=>c.alive).length<Math.min(5+wave,15)) chickens.push(new Chicken(getSpeedMult(wave)));
  }

  chickens.forEach(c=>c.update(dt));
  chickens=chickens.filter(c=>!c.offScreen());
  chickens.forEach(c=>c.draw());

  powerups.forEach(p=>p.update(dt));
  powerups=powerups.filter(p=>p.alive);
  powerups.forEach(p=>p.draw());

  updateParticles(dt);
  drawParticles();

  if(gameState==='playing') drawCrosshair();
  ctx.restore();

  requestAnimationFrame(gameLoop);
}

// ====== EVENTS ======
canvas.addEventListener('mousemove',e=>{mouseX=e.clientX;mouseY=e.clientY;});
canvas.addEventListener('click',e=>{ ensureAudio(); shoot(e.clientX,e.clientY); });
canvas.addEventListener('contextmenu',e=>{e.preventDefault();reload();});
document.addEventListener('keydown',e=>{if(e.code==='KeyR'||e.code==='Space'){e.preventDefault();reload();}});

// Touch support for mobile
canvas.addEventListener('touchstart',e=>{
  e.preventDefault(); ensureAudio();
  const touch=e.touches[0];
  mouseX=touch.clientX; mouseY=touch.clientY;
  shoot(touch.clientX,touch.clientY);
},{passive:false});
canvas.addEventListener('touchmove',e=>{
  const touch=e.touches[0];
  mouseX=touch.clientX; mouseY=touch.clientY;
},{passive:true});

// Reload button (mobile)
document.getElementById('reloadBtn').addEventListener('click',e=>{
  e.stopPropagation(); ensureAudio(); reload();
});
document.getElementById('reloadBtn').addEventListener('touchstart',e=>{
  e.stopPropagation(); e.preventDefault(); ensureAudio(); reload();
},{passive:false});

startBtn.addEventListener('click',()=>{ ensureAudio(); startGame(); });

function startGame(){
  score=0;wave=1;waveKills=0;timeLeft=30;ammo=maxAmmo;totalShots=0;totalHits=0;
  currentWeapon='pistol';specialAmmo=0;waveTransitioning=false;
  chickens=[];particles=[];feathers=[];powerups=[];
  waveTarget=getWaveTarget(1);
  scoreDisplay.textContent='0'; timeDisplay.textContent='30'; timeDisplay.className='';
  updateAmmoUI(); updateWeaponUI(); updateWaveUI();
  overlay.classList.add('hidden');
  nukeFlash.classList.remove('active');
  generateLandscape();
  startWave();
  gameState='playing';
}

window.restartGame = function(){ ensureAudio(); startGame(); };

// ====== INIT ======
generateLandscape();
updateAmmoUI();
lastTime=0;
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
